#summary Расширенный набор команд БЭВМ

= Расширенный набор команд [bcomp БЭВМ] =

<wiki:toc max_depth="3"/>

= Набор команд =
|| *Наименование* || *Мнемоника* || *Код* || *Описание* ||
|||||||| *Безадресные команды* ||
|| Нет операции || NOP || 0000 || ||
|| Останов || HLT || 0100 || ||
|| Разрешение прерываний || EI || 0200 || ||
|| Запрещение прерываний || DI || 0300 || ||
||||||||||
|| Очистка флага переноса || CLC || 0400 || 0 → С ||
|| Инверсия флага переноса || CMC || 0500 || (!С) → С ||
||||||||||
|| Циклический сдвиг влево || ROL || 0600 || Содержимое А и С циклически сдвигается влево ||
|| _Сдвиг влево_ || _SHL_ || 0680 || Содержимое А сдвигается влево c заполнением старшего бита нулём ||
|| Циклический сдвиг вправо || ROR || 0700 || Содержимое А и С циклически сдвигается вправо ||
|| _Сдвиг вправо_ || _SHR_ || 0780 || Содержимое А сдвигается вправо c заполнением младшего бита нулём ||
||||||||||
|| Очистка аккумулятора || CLA || 0800 || 0 → А ||
|| Инверсия аккумулятора || CMA || 0900 || (!А) → А ||
|| Инкремент аккумулятора || INC || 0A00 || (А) + 1 → А ||
|| Декремент аккумулятора || DEC || 0B00 || (А) - 1 → А ||
||||||||||
|| _Обмен аккумулятора с вершиной стека_ || _SWAP_ || 0C00 || (A) ↔ ((7FF)) ||
|| _Помещение аккумулятора в стек_ || _PUSH_ || 0D00 || (7FF) - 1 → 7FF, A → (7FF) ||
|| _Помещение РС в стек_ || _PUSHF_ || 0D80 || (7FF) - 1 → 7FF, РС → (7FF) ||
|| _Получение аккумулятора из стека_ || _POP_ || 0E00 || ((7FF)) → A, (7FF) + 1 → 7FF||
|| _Получение РС из стека_ || _POPF_ || 0E80 || ((7FF)) → C, N, Z, EI, (7FF) + 1 → 7FF ||
||||||||||
|| _Возврат из подпрограммы_ || _RET_ || 0F00 || ((7FF)) → СК, (7FF) + 1 → 7FF ||
|| _Возврат из прерывания_ || _IRET_ || 0F80 || ((7FF)) → СК, (7FF) + 1 → 7FF, ((7FF)) → C, N, Z, EI, (7FF) + 1 → 7FF ||
|||||||| *Команды ввода-вывода* ||
|| Очистка флага ВУ || CLF ВУ || 10XX || ||
|| Опрос флага ВУ || TSF ВУ || 11XX || Если флаг ВУ = 1, то (СК) + 1 → СК ||
|| Ввод || IN ВУ || 12XX || (ВУ) → А ||
|| Вывод || OUT ВУ || 13XX || (А) → ВУ ||
|||||||| *Адресные команды* ||
|| _Обращение к подпрограмме_ || _CALL М_ || 2XXX || (7FF) - 1 → 7FF, (СК) → (7FF); М → СК ||
|| Безусловный переход || JMP М || 3XXX || М → СК ||
||||||||||
|| Переход, если перенос || BCS М || 4XXX || Если (С) = 1, то М → СК ||
|| Переход, если плюс || BPL М || 5XXX || Если (А) ≥ 0, то М → СК ||
|| Переход, если минус || BMI М || 6XXX || Если (А) < 0, то М → СК ||
|| Переход, если нуль || BEQ М || 7XXX || Если (А) = 0, то М → СК ||
||||||||||
|| Пересылка || MOV М || 8XXX || (A) → М ||
|| _Сравнение_ || _CMP М_ || 9XXX || (A) - (М) → C, N, Z ||
|| _Декремент и пропуск_ || _LOOP М_ || AXXX || (М) - 1 → М; Если (М) ≥ 0, то (СК) + 1 → СК ||
|| Приращение и пропуск || ISZ М || BXXX || (М) + 1 → М; Если (М) ≥ 0, то (СК) + 1 → СК ||
||||||||||
|| Вычитание || SUB М || CXXX || (A) - (М) → A ||
|| Сложение с переносом || ADC М || DXXX || (A) + (С) + (М) → A ||
|| Сложение || ADD М || EXXX || (A) + (М) → A ||
|| Логическое умножение || AND М || FXXX || (A) & (М) → A ||

_Выделены_ [ExtendedInstrSet#%D0%9D%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B новые команды].

= Реализация =
Расширенный набор команд реализован в:
 # [ExtendedMicroProgram Расширенной микропрограмме]

= Ограничения =
 # Данный набор команд представлен в ознакомительных целях. Использование расширенного набора команд и [ExtendedMicroProgram расширенной микропрограммы] при выполнении лабораторных работ, домашних заданий и при написании рубежного контроля запрещено
 # Программы, использующие расширенный набор команд, бинарно несовместимы с программами, написанными с использованием [BaseInstrSet оригинального набора команд]
 # Для программ, использующих стэк, выполнение пультовой операции `Пуск` является обязательным

= Стэк =
В связи с отсутствием в БЭВМ регистра для хранение указателя стэка используется ячейка памяти с адресом 7FF. Указатель стэка устанавливается в значение по умолчанию при выполнении пультовой операции `Пуск`.

= Отличия набора команд =
 # Коды всех команд изменены
 # Мнемоника команды BR изменена на JMP
 # Команда JSR заменена новой командой CALL

= Новые команды =
 # LOOP - осуществляет декремент указанной ячейки и пропускает следующую команду до тех пор, пока значение ячейки не станет отрицательным. Предназначена для организации циклов с предусловием
 # CMP - вычитает из содержимого аккумулятора содержимое указанной ячейки и сохраняет результат во флагах C, N, Z
 # CALL - переход к подпрограмме с сохранением адреса возврата в стэке
 # RET - возврат из подпрограммы
 # IRET - возврат из подпрограммы обработки прерывания. Восстанавливает из стэка значения СК и флагов C, N, Z, EI
 # PUSH - сохраняет значение А в стэке
 # POP - восстанавливает значение А из стэка
 # PUSHF - сохраняет значение РС в стэке
 # POPF - восстанавливает значение флагов C, N, Z, EI из стэка
 # SWAP - обменивает содержимое А с вершиной стэка
 # SHL - сдвиг содержимого А влево с заполнением старшего бита А нулём
 # SHR - сдвиг содержимого А вправо с заполнением младшего бита А нулём

= Примеры использования =
== Вычисление произведения двух чисел ==
{{{
ORG 10
BEGIN:	CLA
	MOV	R
	ADD	Y
	PUSH
	CLA
	ADD	X
LOOP:	BEQ	DONE
	SHR
	SWAP
	BCS	ADDUP
	JMP	SKIP
ADDUP:	PUSH
	ADD	R
	MOV	R
	POP
SKIP:	SHL
	SWAP
	JMP	LOOP
DONE:	POP
	HLT

X:	WORD	?
Y:	WORD	?
R:	WORD	?
}}}

== Вычисление факториала числа ==
=== Используя для умножения операцию сложения ===
{{{
ORG 10
BEGIN:
	CLA
	ADD	X
	CALL	FACTORIAL
	MOV	R
	HLT

ORG 18
X:	WORD	8
R:	WORD	?

ORG 20
FACTORIAL:
	CMP	CONST
	BEQ	FINISH
	PUSH
	DEC
	CALL	FACTORIAL
	MOV	VALUE
	POP
	MOV	COUNT
	CLA
LOOP:	LOOP	COUNT
FINISH:	RET
	ADD	VALUE
	JMP	LOOP

CONST:	WORD	1
VALUE:	WORD	?
COUNT:	WORD	?
}}}

=== Используя для умножения подпрограмму ===
{{{
ORG 10
BEGIN:
	CLA
	ADD	X
	CALL	FACTORIAL
	MOV	R
	HLT

ORG 18
X:	WORD	8
R:	WORD	?

ORG 20
FACTORIAL:
	CMP	CONST
	BEQ	FINISH
	PUSH
	DEC
	CALL	FACTORIAL
	CALL	MUL
FINISH:	RET
	
CONST:	WORD	1

ORG 30
MUL:	SWAP
	MOV	RETURN
	CLA
	MOV	SUM
	POP
LOOP:	BEQ	DONE
	SHR
	SWAP
	BCS	ADDUP
	JMP	SKIP
ADDUP:	PUSH
	ADD	SUM
	MOV	SUM
	POP
SKIP:	SHL
	SWAP
	JMP	LOOP
DONE:	POP
	CLA
	ADD	SUM
	JMP	(RETURN)
SUM:	WORD	?
RETURN:	WORD	?
}}}

== Обработка прерываний ==
=== Требования ===
 # В основной программе должно циклически сдвигаться содержимое ячейки R, всегда содержащее один единичный бит.
 # Раз в десять секунд должно увеличиваться содержимое ячейки T.
 # При запросе от ВУ1 выводить на него значение ячейки X.
 # При запросе от ВУ2 сохранять введённое в РД ВУ2 значение в ячейку X.
 # При запросе от ВУ3 обменивать местами значение его РД и ячейки X.
 # Обмен с ВУ осуществлять в режиме прерывания.
=== Решение ===
{{{
ORG 000
	WORD	INTR

ORG 010
BEGIN:	
	CLA
	MOV	T
	ADD	CONST
	OUT	0
	EI
	CLA
	INC
LOOP:	ROR
	BCS	LOOP
	MOV	R
	JMP	LOOP

ORG 01C
CONST:	WORD	A
X:	WORD	0
T:	WORD	?
R:	WORD	?

INTR:	PUSH
	TSF	0
	JMP	IO1
	CLF	0
	ISZ	T
	NOP
IO1:	TSF	1
	JMP	IO2
	CLA
	ADD	X
	OUT	1
	CLF	1
IO2:	TSF	2
	JMP	IO3
	CLA
	IN	2
	CLF	2
	MOV	X
IO3:	TSF	3
	JMP	END
	CLA
	ADD	X
	PUSH
	IN	3
	MOV	X
	POP
	OUT	3
	CLF	3
END:	POP
	IRET
}}}
