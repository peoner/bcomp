#summary Ассемблер БЭВМ

= Ассемблер [bcomp БЭВМ] =

<wiki:toc max_depth="3"/>

= Синтаксис =
|| *Назначение* || *Синтаксис* || *Пример использования* ||
|| Управление размещением в памяти || `ORG адрес` || `ORG 10` ||
|| Адресная команда с прямой адресацией || `[метка:] МНЕМОНИКА АРГУМЕНТ` || `MOV R` ||
|| Адресная команда с косвенной адресацией || `[метка:] МНЕМОНИКА (АРГУМЕНТ)` || `ADD (K)` ||
|| Безадресная команда || `[метка:] МНЕМОНИКА` || `BEGIN: CLA` ||
|| Команда ввода-вывода || `[метка:] МНЕМОНИКА АДРЕСВУ` || `OUT 3` ||
|| Константы || `[метка:] WORD значениe[,значениe...]`<br>`[[метка:] WORD количество DUP (значение)` || `X: WORD ?`<br>`Y: WORD X`<br>`VALUES: WORD 1,2,3`<br>`ARRAY: WORD 10 DUP (?)` ||

Метки, команды, их аргументы и т.п. должны быть отделены друг от друга пробелом или символом табуляции.

= Описание директив =
 # `ORG address` - указывает компилятору, что следующее значение необходимо располагать по указанному адресу. Похожа на пультовую команду "Ввод адреса". Обычно данную директивую достаточно использовать один раз в начале программы.
 # `WORD` - ввод констант и резервирование памяти. Может быть указано одно или более значений. Если в качестве значения указан вопросительный знак, то соответствующая ячейка памяти остаётся неинициализированной. Если указанное значение не удалось распознать как шестнадцатеричное число, то в качестве значения будет использован адрес метки с указанным именем. При использовании в синтаксисе `WORD количество DUP (значение)` соответствующее значение будет продублировано указанное количество раз.

= Метки =
Метки являются ссылками на соответствующие ячейки памяти. Могут использоваться как аргументы для адресных команд и для инициализации других ячеек адресом, на которую ссылается метка. В имени метки могут использоваться любые символы, однако, в связи с особенностями обработки констант, не рекомендуется использовать имена меток, которые могут быть восприняты как шестнадцатеричное число.

= Специальные метки =
 # BEGIN - указывает компилятору на первую выполняемую команду программы. Должна быть указана в любой программе.
 # R - указывает на ячейку, в которой будет располагаться результат. После успешной компиляции, если в программе была обнаружена метка R, [cli консольная версия БЭВМ] выведет адрес соответствующей ячейки памяти.

= Комментарии =
Любой текст в строке после символа ; или # считается комментарием.

= Ограничения и известные проблемы =
 # Все вводимые значения воспринимаются в шестнадцатеричной системе и диапозон допустимых значений не проверяется. Следует обратить внимание, что, например, значения `8000` и `-8000` будут интерпретированы как одно и тоже число.
 # Аргументы адресных команд воспринимаются как имя метки *только* если не являются шестнадцатеричным числом.
 # Обработка и диагностика ошибок находятся в зачаточном состоянии.
 # При использовании директивы `ORG` компилятор не отслеживает возможное перекрытие частей программы. Приведённые ниже код скомпилируется без ошибок, но в памяти БЭВМ окажется некорректная программа.
{{{
ORG	10
BEGIN:	CLA
	ADD	X
	ADD	Y
	MOV	R
	HLT

ORG	12
X:	WORD	DEAD
Y:	WORD	BEEF
R:	WORD	?
}}}

= Примеры использования =
== Сложение двух чисел ==
{{{
ORG	010
BEGIN:	CLA
	ADD	X
	ADD	Y
	MOV	R
	HLT

ORG	018
R:	WORD	?
X:	WORD	DEAD
Y:	WORD	BEEF
}}}

== Подсчёт количества неотрицательных элементов в массиве ==

=== Решение 1. Старый стиль ===
{{{
ORG	00F
	WORD	0020
BEGIN:	WORD	F200,480F,A017,F200,401B,F800,301B,001A,C010,F000,FFFA,0000
ORG	020
	WORD	0001,FFFF,0002,FFFE,0003,FFFD
}}}
==== Преимущества: ====
 # Работает.
 # Ввод программы максимально приближен к обычной работе с [bcomp БЭВМ].
==== Недостатки: ====
 # Собственно возможности ассемблера не используются.
 # Из текста программы не понятно где расположены команды, а где данные и результат.

=== Решение 2. Студенческое ===
{{{
ORG	00F
	WORD	0020

BEGIN:	CLA
	ADD	(00F)
	BMI	SKIP
	CLA
	ADD	R
	INC
	MOV	R
SKIP:	ISZ	01A
	BR	BEGIN
	HLT

	WORD	-6
R:	WORD	?

ORG	020
X:	WORD	0001, FFFF, 0002, FFFE, 0003, FFFD
}}}
==== Преимущества: ====
 # Тоже работает.
==== Недостатки: ====
 # Из поля зрения выпадают исходные данные хранящие адрес первого элемента массива и их количество.
 # При повторном запуске программы с новыми данными результат может быть некорректным.

=== Решение 3. Правильное ===
{{{
ORG	00F
K:	WORD	?	; Адрес первого элемента массива

BEGIN:	CLA
	MOV	R
	ADD	(K)
	BMI	SKIP
	CLA
	ADD	R
	INC
	MOV	R
SKIP:	ISZ	N
	BR	BEGIN
	HLT

N:	WORD	?	; Количество элементов массива
R:	WORD	?	; Результат

ORG	020
X:	WORD	6 DUP (?)	; Элементы массива
}}}
==== Преимущества: ====
 # Видны все исходные данные, используемые программой.
 # При повторном запуске программы с новыми исходными данными результат будет корректным.
==== Недостатки: ====
 # Перед запуском программы пользователь должен самостоятельно ввести все исходные данные.
 # Пользователь может ошибочно посчитать, что программа может работать только с массивом из 6 элементов.

== Обработка прерываний ==
=== Требования ===
 # В основной программе должно циклически сдвигаться содержимое ячейки R, всегда содержащее один единичный бит.
 # Раз в десять секунд должно увеличиваться содержимое ячейки T.
 # При запросе от ВУ1 выводить на него значение ячейки X.
 # При запросе от ВУ2 сохранять введённое в РД ВУ2 значение в ячейку X.
 # При запросе от ВУ3 обменивать местами значение его РД и ячейки X.
 # Обмен с ВУ осуществлять в режиме прерывания.
=== Решение ===
{{{
ORG	000
RET:	WORD	?
	BR	INT

ORG	010
BEGIN:	CLA
	MOV	T
	ADD	CONST
	OUT	0
	EI
	CLA
	INC
LOOP:	ROR
	BCS	LOOP
	MOV	R
	BR	LOOP

ORG	01C
CONST:	WORD	A
X:	WORD	0
T:	WORD	?
R:	WORD	?

INT:	MOV	A
	ROL
	MOV	C
	TSF	0
	BR	IO1
	CLF	0
	ISZ	T
	NOP
IO1:	TSF	1
	BR	IO2
	CLA
	ADD	X
	OUT	1
	CLF	1
IO2:	TSF	2
	BR	IO3
	CLA
	IN	2
	CLF	2
	MOV	X
IO3:	TSF	3
	BR	END
	CLA
	IN	3
	MOV	TMP
	CLA
	ADD	X
	OUT	3
	CLF	3
	CLA
	ADD	TMP
	MOV	X
END:	CLA
	ADD	C
	ROR
	CLA
	CMA
	AND	A
	EI
	BR	(RET)
TMP:	WORD	?
A:	WORD	?
C:	WORD	?
}}}
При выполнении данной программы в [gui графической реализации эмулятора] рекомендуется [gui#%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B3%D0%BE%D1%80%D1%8F%D1%87%D0%B8%D1%85_%D0%BA%D0%BB%D0%B0%D0%B2%D0%B8%D1%88 уменьшить задержку между тактами].
